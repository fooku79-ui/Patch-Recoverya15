name: Patch Recovery

on:
  workflow_dispatch:
    inputs:
      recovery_url:
        description: "Direct URL to recovery.img (or .img.gz/.img.xz)"
        required: true
        type: string
      patch_script:
        description: "Path to your custom patch script in repo (optional)"
        required: false
        default: "scripts/patch.sh"
        type: string
  push:
    paths:
      - ".github/workflows/recovery.yml"
      - "scripts/**"
      - "tools/**"

jobs:
  patch:
    runs-on: ubuntu-22.04
    timeout-minutes: 20

    env:
      AIK_DIR: ${{ github.workspace }}/AIK
      OUT_DIR: ${{ github.workspace }}/out
      RECOVERY_IMG: ${{ github.workspace }}/recovery.img
      PATCH_SCRIPT: ${{ github.event.inputs.patch_script }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git curl ca-certificates unzip xz-utils gzip zstd lz4 \
            cpio gawk sed grep python3 python3-pip openssl coreutils file

      - name: Fetch Android Image Kitchen
        run: |
          git clone --depth=1 https://github.com/osm0sis/Android-Image-Kitchen.git "$AIK_DIR"
          chmod +x "$AIK_DIR"/AIK-linux.sh "$AIK_DIR"/*.{sh,py} || true
          echo "$AIK_DIR" >> $GITHUB_PATH

      - name: Fetch avbtool (AOSP)
        run: |
          curl -L \
            https://raw.githubusercontent.com/LineageOS/android_external_avb/lineage-20/avbtool.py \
            -o avbtool
          chmod +x avbtool
          sudo mv avbtool /usr/local/bin/avbtool

      - name: Verify tools present
        run: |
          test -x "$AIK_DIR/bin/magiskboot"
          test -x /usr/local/bin/avbtool
          echo "âœ… magiskboot and avbtool available."

      - name: Download recovery image
        run: |
          mkdir -p "$OUT_DIR"
          URL="${{ github.event.inputs.recovery_url }}"
          echo "Downloading: $URL"
          curl -L "$URL" -o recovery.dl
          case "$URL" in
            *.img)   mv recovery.dl "$RECOVERY_IMG" ;;
            *.img.gz)  gunzip -c recovery.dl > "$RECOVERY_IMG" ;;
            *.img.xz)  xz -dc recovery.dl > "$RECOVERY_IMG" ;;
            *.img.zst) zstd -dc recovery.dl > "$RECOVERY_IMG" ;;
            *) file recovery.dl; mv recovery.dl "$RECOVERY_IMG" ;;
          esac
          ls -lh "$RECOVERY_IMG"

      - name: Sanity check image
        run: |
          file "$RECOVERY_IMG"
          # Lightweight Android header check; won't catch every variant but filters obvious junk.
          if ! strings "$RECOVERY_IMG" | grep -qi -e ANDROID -e SEANDROID -e "ANDROID!"; then
            echo "âŒ Not seeing Android magic in recovery image. Proceeding may be pointless."
            exit 1
          fi
          echo "âœ… Looks like an Android recovery image."

      - name: Unpack recovery
        run: |
          rm -rf work && mkdir -p work
          cp "$RECOVERY_IMG" work/recovery.img
          pushd work >/dev/null
          "$AIK_DIR"/unpackimg.sh recovery.img
          echo "Contents:"
          ls -al
          popd >/dev/null

      - name: Optional custom patch
        if: ${{ hashFiles(env.PATCH_SCRIPT) != '' }}
        run: |
          echo "Running custom patch script: $PATCH_SCRIPT"
          chmod +x "$PATCH_SCRIPT" || true
          # Provide paths for your script:
          export AIK_DIR="$AIK_DIR"
          export WORK_DIR="${{ github.workspace }}/work"
          export RAMDISK_DIR="${{ github.workspace }}/work/ramdisk"
          # Common ramdisk locations created by AIK
          if [ -d "$WORK_DIR/ramdisk" ]; then export RAMDISK_DIR="$WORK_DIR/ramdisk"; fi
          if [ -d "$WORK_DIR/vendor_ramdisk" ]; then export VENDOR_RAMDISK_DIR="$WORK_DIR/vendor_ramdisk"; fi
          "$PATCH_SCRIPT"

      - name: Minimal safety tweaks (no-op if not applicable)
        run: |
          set -e
          WORK_DIR="${{ github.workspace }}/work"
          # Example: prevent recovery-from-boot restoration if present
          if [ -f "$WORK_DIR/ramdisk/sbin/recovery" ] || [ -f "$WORK_DIR/ramdisk/sbin/recovery-init" ]; then
            echo "ðŸ”§ Attempting common anti-restore tweak."
          fi
          # Add your generic edits here if you don't use a custom script.

      - name: Repack recovery
        run: |
          pushd work >/dev/null
          "$AIK_DIR"/repackimg.sh
          test -f image-new.img
          mv image-new.img "$OUT_DIR/recovery_patched.img"
          popd >/dev/null
          sha256sum "$OUT_DIR/recovery_patched.img" | tee "$OUT_DIR/recovery_patched.sha256"

      - name: AVB info (best-effort)
        continue-on-error: true
        run: |
          avbtool info_image --image "$OUT_DIR/recovery_patched.img" || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: recovery-patched
          path: |
            ${{ env.OUT_DIR }}/recovery_patched.img
            ${{ env.OUT_DIR }}/recovery_patched.sha256
          if-no-files-found: error
