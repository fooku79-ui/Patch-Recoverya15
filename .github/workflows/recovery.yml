name: Patch Recovery Image

on:
  workflow_dispatch:
    inputs:
      recovery_url:
        description: 'Direct URL to recovery.img file'
        required: true
        type: string
      device_model:
        description: 'Samsung device model (e.g., SM-A515F)'
        required: true
        type: string

jobs:
  patch-recovery:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y wget curl unzip lz4 xz-utils xxd
        
    - name: Download and setup tools
      run: |
        wget https://github.com/topjohnwu/Magisk/releases/latest/download/Magisk-v26.4.zip -O magisk.zip
        unzip magisk.zip
        chmod +x magiskboot
        mkdir -p scripts
        
    - name: Create validation script
      run: |
        cat > scripts/validate.sh << 'EOF'
        #!/bin/bash
        set -euo pipefail
        
        RECOVERY_IMG="$1"
        echo "üîç validate.sh: checking $RECOVERY_IMG"
        
        if [ ! -f "$RECOVERY_IMG" ]; then
            echo "‚ùå File $RECOVERY_IMG does not exist"
            exit 1
        fi
        
        FILE_TYPE=$(file "$RECOVERY_IMG")
        echo "File type: $FILE_TYPE"
        
        if [[ "$FILE_TYPE" == *"LZ4"* ]]; then
            echo "üîß Detected LZ4 compressed file, decompressing..."
            lz4 -d "$RECOVERY_IMG" "${RECOVERY_IMG}.decompressed"
            mv "${RECOVERY_IMG}.decompressed" "$RECOVERY_IMG"
        fi
        
        if [[ "$FILE_TYPE" == *"XZ"* ]] || [[ "$FILE_TYPE" == *"LZMA"* ]]; then
            echo "üîß Detected XZ/LZMA compressed file, decompressing..."
            xz -d "$RECOVERY_IMG"
        fi
        
        if [[ "$FILE_TYPE" == *"gzip"* ]]; then
            echo "üîß Detected gzip compressed file, decompressing..."
            gunzip "$RECOVERY_IMG"
        fi
        
        MAGIC=$(xxd -l 8 -p "$RECOVERY_IMG" 2>/dev/null || true)
        if [[ "$MAGIC" == "414e44524f494421" ]]; then
            echo "‚úÖ Found Android boot image magic (ANDROID!)"
            exit 0
        fi
        
        echo "‚ùå Not detecting Android boot image magic in $RECOVERY_IMG"
        echo "Magic bytes found: $MAGIC (expected: 414e44524f494421)"
        echo "First 32 bytes of file:"
        xxd -l 32 "$RECOVERY_IMG" || true
        exit 1
        EOF
        chmod +x scripts/validate.sh
        
    - name: Create patch script
      run: |
        cat > scripts/patch.sh << 'EOF'
        #!/bin/bash
        set -euo pipefail
        
        RECOVERY_IMG="$1"
        OUTPUT_DIR="output"
        
        echo "üîß patch.sh: patching $RECOVERY_IMG"
        mkdir -p "$OUTPUT_DIR"
        
        ./magiskboot unpack "$RECOVERY_IMG"
        
        if [ ! -f "ramdisk.cpio" ]; then
            echo "‚ùå ramdisk.cpio not found after unpacking"
            exit 1
        fi
        
        mkdir -p ramdisk
        cd ramdisk
        cpio -idm < ../ramdisk.cpio
        
        mkdir -p system/bin
        
        for rc_file in *.rc; do
            if [ -f "$rc_file" ]; then
                echo "üîß Patching $rc_file"
                if ! grep -q "service fastbootd" "$rc_file"; then
                    cat >> "$rc_file" << 'RCEOF'
        
        service fastbootd /system/bin/fastbootd
            class core
            user root
            group root system
            disabled
            seclabel u:r:fastbootd:s0
        
        on property:sys.usb.config=fastboot
            start fastbootd
        
        RCEOF
                fi
            fi
        done
        
        for fstab_file in fstab.*; do
            if [ -f "$fstab_file" ]; then
                echo "üîß Patching $fstab_file for dynamic partitions"
                if ! grep -q "system.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/system /system ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                fi
                if ! grep -q "vendor.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/vendor /vendor ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                fi
                if ! grep -q "product.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/product /product ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                fi
            fi
        done
        
        find . | cpio -o -H newc > ../ramdisk.cpio.new
        cd ..
        mv ramdisk.cpio.new ramdisk.cpio
        
        ./magiskboot repack "$RECOVERY_IMG" "$OUTPUT_DIR/recovery-patched.img"
        
        if [ -f "$OUTPUT_DIR/recovery-patched.img" ]; then
            SIZE=$(stat -c%s "$OUTPUT_DIR/recovery-patched.img")
            echo "‚úÖ Patched recovery created: $SIZE bytes"
        else
            echo "‚ùå Failed to create patched recovery"
            exit 1
        fi
        
        echo "üéâ Patching completed successfully!"
        EOF
        chmod +x scripts/patch.sh
        
    - name: Download recovery image
      run: |
        echo "‚¨áÔ∏è Downloading recovery image from: ${{ github.event.inputs.recovery_url }}"
        wget "${{ github.event.inputs.recovery_url }}" -O recovery.img
        ls -lh recovery.img
        file recovery.img
        
    - name: Validate recovery image
      run: |
        export RECOVERY_IMG="$PWD/recovery.img"
        scripts/validate.sh "$RECOVERY_IMG"
        
    - name: Patch recovery image
      run: |
        export RECOVERY_IMG="$PWD/recovery.img"
        scripts/patch.sh "$RECOVERY_IMG"
        
    - name: Upload patched recovery
      uses: actions/upload-artifact@v4
      with:
        name: patched-recovery-${{ github.event.inputs.device_model }}
        path: output/recovery-patched.img
        retention-days: 30
