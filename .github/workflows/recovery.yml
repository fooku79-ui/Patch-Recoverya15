name: Patch Recovery (Single-File, Self-Contained)

on:
  workflow_dispatch:
    inputs:
      recovery_url:
        description: "Direct URL to recovery image (.img/.img.gz/.img.xz/.img.zst/.img.lz4)"
        required: true
        type: string
      output_name:
        description: "Output filename"
        required: false
        default: "recovery_patched.img"
        type: string

jobs:
  patch:
    runs-on: ubuntu-22.04
    timeout-minutes: 25

    env:
      WORK_DIR: ${{ github.workspace }}/work
      OUT_DIR: ${{ github.workspace }}/out
      RECOVERY_IMG: ${{ github.workspace }}/recovery.img

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git curl file xz-utils zstd gzip lz4 cpio unzip python3 tar

      - name: Create helper scripts (inline)
        run: |
          set -euxo pipefail
          mkdir -p scripts

          # validate.sh
          cat > scripts/validate.sh << 'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          : "${RECOVERY_IMG:?missing RECOVERY_IMG}"
          echo "🔍 validate.sh: checking $RECOVERY_IMG"
          file "$RECOVERY_IMG" || true
          if ! strings "$RECOVERY_IMG" | grep -qi -e ANDROID -e SEANDROID -e "ANDROID!"; then
            echo "❌ Not detecting Android boot image magic in $RECOVERY_IMG"
            exit 1
          fi
          echo "✅ validate.sh: basic checks passed"
          EOF
          chmod +x scripts/validate.sh

          # patch.sh
          cat > scripts/patch.sh << 'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          : "${WORK_DIR:?missing WORK_DIR}"
          tag_dir() {
            local d="$1"
            [ -d "$d" ] || return 0
            mkdir -p "$d/etc" || true
            {
              echo "patched_by=github_actions"
              echo "patched_at=$(date -u +%FT%TZ)"
            } > "$d/etc/recovery_patch.meta"
          }
          neuter_restore() {
            local d="$1"
            [ -d "$d" ] || return 0
            for f in "$d"/{sbin,bin,etc}/install-recovery.sh "$d"/{sbin,bin,etc}/recovery-from-boot.p; do
              [ -f "$f" ] || continue
              mv -f "$f" "$f.disabled"
            done
            # Also rewrite references in init scripts if present
            grep -RIl -e "install-recovery.sh" -e "recovery-from-boot.p" "$d" 2>/dev/null | while read -r f; do
              sed -i 's/install-recovery\.sh/install-recovery.sh.disabled/g' "$f" || true
              sed -i 's/recovery-from-boot\.p/recovery-from-boot.p.disabled/g' "$f" || true
            done
          }
          permissify() {
            local d="$1"
            [ -d "$d" ] || return 0
            find "$d" -type f -name "*.sh" -exec chmod 0755 {} + || true
            [ -d "$d/sbin" ] && chmod 0755 "$d/sbin"/* 2>/dev/null || true
          }
          for D in "$WORK_DIR/ramdisk" "$WORK_DIR/vendor_ramdisk"; do
            [ -d "$D" ] || continue
            tag_dir "$D"
            neuter_restore "$D"
            permissify "$D"
          done
          echo "✅ patch.sh: done"
          EOF
          chmod +x scripts/patch.sh

      - name: Fetch Android Image Kitchen
        run: |
          set -euxo pipefail
          git clone --depth=1 https://github.com/osm0sis/Android-Image-Kitchen AIK
          echo "Using AIK at $PWD/AIK"

      - name: Download recovery image
        run: |
          set -euxo pipefail
          mkdir -p "$WORK_DIR" "$OUT_DIR"
          URL="${{ inputs.recovery_url }}"
          echo "Downloading: $URL"
          curl -fL "$URL" -o input.bin
          case "$URL" in
            *.img)       mv input.bin "$RECOVERY_IMG" ;;
            *.img.gz)    gunzip -c input.bin > "$RECOVERY_IMG" ;;
            *.img.xz)    xz -dc input.bin > "$RECOVERY_IMG" ;;
            *.img.zst)   zstd -dc input.bin > "$RECOVERY_IMG" ;;
            *.img.lz4)   lz4 -dq input.bin "$RECOVERY_IMG" ;;
            *)           file input.bin; mv input.bin "$RECOVERY_IMG" ;;
          esac
          ls -lh "$RECOVERY_IMG"

      - name: Sanity check image
        run: |
          set -euxo pipefail
          RECOVERY_IMG="${{ env.RECOVERY_IMG }}" scripts/validate.sh

      - name: Unpack
        run: |
          set -euxo pipefail
          cp "$RECOVERY_IMG" "$WORK_DIR/recovery.img"
          bash AIK/unpackimg.sh "$WORK_DIR/recovery.img"
          echo "Contents:"
          ls -al "$WORK_DIR" || true

      - name: Patch (neutralize stock-restore, fix perms)
        run: |
          set -euxo pipefail
          WORK_DIR="${{ env.WORK_DIR }}" scripts/patch.sh

      - name: Repack
        run: |
          set -euxo pipefail
          pushd "$WORK_DIR" >/dev/null
          bash ../AIK/repackimg.sh
          popd >/dev/null
          test -f "$WORK_DIR/image-new.img"
          mv "$WORK_DIR/image-new.img" "$OUT_DIR/${{ inputs.output_name }}"
          sha256sum "$OUT_DIR/${{ inputs.output_name }}" | tee "$OUT_DIR/${{ inputs.output_name }}.sha256"

      - name: Optional Odin tar.md5 wrapper
        run: |
          set -euxo pipefail
          pushd "$OUT_DIR"
          cp "${{ inputs.output_name }}" recovery.img
          tar -H ustar -c recovery.img > recovery.tar
          md5sum -t recovery.tar | sed 's/ .*//' >> recovery.tar
          mv recovery.tar recovery.tar.md5
          popd
          ls -lh "$OUT_DIR"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: patched-recovery
          path: ${{ env.OUT_DIR }}/
          if-no-files-found: error
