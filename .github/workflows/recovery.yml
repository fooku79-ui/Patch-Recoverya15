name: Patch Recovery

on:
  workflow_dispatch:
    inputs:
      RECOVERY_URL:
        description: "Direct HTTPS URL to recovery image (.img/.img.lz4/.img.gz/.img.xz/.img.zst)"
        required: true
        type: string
      OUTPUT_NAME:
        description: "Output filename (e.g., recovery_patched.img)"
        required: false
        default: "recovery_patched.img"
        type: string

jobs:
  patch:
    runs-on: ubuntu-22.04
    timeout-minutes: 25

    env:
      OUT_DIR: ${{ github.workspace }}/out
      WORK_DIR: ${{ github.workspace }}/work
      RECOVERY_IMG: ${{ github.workspace }}/recovery.img

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            curl file xz-utils zstd gzip lz4 cpio unzip git python3

      - name: Make bundled tools executable (repo root)
        run: |
          set -euxo pipefail
          # If you keep tools in the repo root, this makes them runnable
          if [ -f ./magiskboot ]; then chmod +x ./magiskboot; fi
          if [ -f ./avbtool ]; then chmod +x ./avbtool; fi
          if [ -f ./script1.sh ]; then chmod +x ./script1.sh; fi
          if [ -f ./script2.sh ]; then chmod +x ./script2.sh; fi

      - name: Fallback: fetch Android Image Kitchen if magiskboot missing
        run: |
          set -euxo pipefail
          if ! [ -x ./magiskboot ]; then
            git clone --depth=1 https://github.com/osm0sis/Android-Image-Kitchen AIK
            cp AIK/AIK-Linux/bin/magiskboot ./magiskboot
            chmod +x ./magiskboot
          fi

      - name: Fallback: fetch avbtool if missing
        run: |
          set -euxo pipefail
          if ! [ -x ./avbtool ]; then
            curl -fL -o avbtool.py \
              "https://raw.githubusercontent.com/LineageOS/android_external_avb/lineage-20/avbtool.py"
            mv avbtool.py avbtool
            chmod +x ./avbtool
          fi
          ./magiskboot --help >/dev/null
          ./avbtool --help >/dev/null

      - name: Download recovery image
        run: |
          set -euxo pipefail
          mkdir -p "$OUT_DIR" "$WORK_DIR"
          URL="${{ inputs.RECOVERY_URL }}"
          echo "Downloading: $URL"
          curl -fL "$URL" -o input.bin
          case "$URL" in
            *.img)       mv input.bin "$RECOVERY_IMG" ;;
            *.img.gz)    gunzip -c input.bin > "$RECOVERY_IMG" ;;
            *.img.xz)    xz -dc input.bin > "$RECOVERY_IMG" ;;
            *.img.zst)   zstd -dc input.bin > "$RECOVERY_IMG" ;;
            *.img.lz4)   lz4 -dq input.bin "$RECOVERY_IMG" ;;
            *)           file input.bin; mv input.bin "$RECOVERY_IMG" ;;
          esac
          ls -lh "$RECOVERY_IMG"

      - name: Sanity check image
        run: |
          set -euxo pipefail
          file "$RECOVERY_IMG" || true
          if ! strings "$RECOVERY_IMG" | grep -qi -e ANDROID -e SEANDROID -e "ANDROID!"; then
            echo "Not seeing Android boot header magic; refusing to continue."
            exit 1
          fi
          echo "Looks like a valid Android recovery image."

      - name: Unpack with AIK (best-effort)
        run: |
          set -euxo pipefail
          # Prefer repo-bundled AIK layout if present
          if [ -d AIK ]; then
            AIK_DIR="$PWD/AIK"
          else
            git clone --depth=1 https://github.com/osm0sis/Android-Image-Kitchen AIK
            AIK_DIR="$PWD/AIK"
          fi
          echo "Using AIK at $AIK_DIR"
          cp "$RECOVERY_IMG" "$WORK_DIR/recovery.img"
          bash "$AIK_DIR/unpackimg.sh" "$WORK_DIR/recovery.img" || true
          ls -al "$WORK_DIR" || true

      - name: Optional custom patch (script1.sh)
        if: ${{ hashFiles('script1.sh') != '' }}
        run: |
          set -euxo pipefail
          export WORK_DIR="${{ env.WORK_DIR }}"
          export RECOVERY_IMG="${{ env.RECOVERY_IMG }}"
          ./script1.sh

      - name: Optional custom patch (script2.sh)
        if: ${{ hashFiles('script2.sh') != '' }}
        run: |
          set -euxo pipefail
          export WORK_DIR="${{ env.WORK_DIR }}"
          export RECOVERY_IMG="${{ env.RECOVERY_IMG }}"
          ./script2.sh

      - name: Repack with AIK if it unpacked
        run: |
          set -euxo pipefail
          if [ -d AIK ]; then
            AIK_DIR="$PWD/AIK"
            pushd "$WORK_DIR" >/dev/null || true
            # repackimg.sh outputs image-new.img when successful
            bash "$AIK_DIR/repackimg.sh" || true
            popd >/dev/null || true
            if [ -f "$WORK_DIR/image-new.img" ]; then
              mv "$WORK_DIR/image-new.img" "$OUT_DIR/${{ inputs.OUTPUT_NAME }}"
            else
              # No repack output; fall back to original with a suffix so you have something to inspect
              cp "$RECOVERY_IMG" "$OUT_DIR/${{ inputs.OUTPUT_NAME }}"
            fi
          else
            # Fallback: just copy through if AIK failed entirely
            cp "$RECOVERY_IMG" "$OUT_DIR/${{ inputs.OUTPUT_NAME }}"
          fi
          sha256sum "$OUT_DIR/${{ inputs.OUTPUT_NAME }}" | tee "$OUT_DIR/${{ inputs.OUTPUT_NAME }}.sha256"

      - name: Wrap to Odin .tar.md5 (optional)
        run: |
          set -euxo pipefail
          pushd "$OUT_DIR"
          cp "${{ inputs.OUTPUT_NAME }}" recovery.img
          tar -H ustar -c recovery.img > recovery.tar
          md5sum -t recovery.tar | sed 's/ .*//' >> recovery.tar
          mv recovery.tar recovery.tar.md5
          popd
          ls -lh "$OUT_DIR"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: patched-recovery
          path: |
            ${{ env.OUT_DIR }}/
          if-no-files-found: error
