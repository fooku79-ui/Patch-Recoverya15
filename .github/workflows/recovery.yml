name: RECOVERY
on:
  workflow_dispatch:
    inputs:
      RECOVERY_URL:
        description: 'RECOVERY URL'
        required: true
        default: 'https://transfer.sh/(RECOMMENDED)'
env:
  RECOVERY_URL: https://oshi.at/Rpjg
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Check Out
      uses: actions/checkout@main
      
    - name: Prepare the environment
      run: |
        sudo apt install git wget lz4 tar openssl python3 xxd cpio -y
        
    - name: Download and setup tools
      run: |
        # Download latest Magisk
        wget https://github.com/topjohnwu/Magisk/releases/download/v29.0/Magisk-v29.0.apk -O magisk.zip
        unzip -j magisk.zip lib/x86_64/libmagiskboot.so
        mv libmagiskboot.so magiskboot
        chmod +x magiskboot
        
        # Download avbtool
        wget "https://android.googlesource.com/platform/external/avb/+/master/avbtool.py?format=TEXT" -O avbtool_b64
        base64 -d avbtool_b64 > avbtool
        chmod +x avbtool
        
        # Create signing key
        openssl genrsa -out phh.pem 4096
        
    - name: Create script1.sh
      run: |
        cat > script1.sh << 'EOF'
        #!/bin/bash
        set -euxo pipefail
        
        RECOVERY_IMG="recovery.img"
        
        echo "ðŸ” script1.sh: validating and preparing $RECOVERY_IMG"
        
        if [ ! -f "$RECOVERY_IMG" ]; then
            echo "âŒ File $RECOVERY_IMG does not exist"
            exit 1
        fi
        
        # Check file type and decompress if needed
        FILE_TYPE=$(file "$RECOVERY_IMG")
        echo "File type: $FILE_TYPE"
        
        if [[ "$FILE_TYPE" == *"LZ4"* ]]; then
            echo "ðŸ”§ Detected LZ4 compressed file, decompressing..."
            lz4 -d "$RECOVERY_IMG" "${RECOVERY_IMG}.decompressed"
            mv "${RECOVERY_IMG}.decompressed" "$RECOVERY_IMG"
        fi
        
        if [[ "$FILE_TYPE" == *"XZ"* ]] || [[ "$FILE_TYPE" == *"LZMA"* ]]; then
            echo "ðŸ”§ Detected XZ/LZMA compressed file, decompressing..."
            xz -d "$RECOVERY_IMG"
        fi
        
        # Validate Android boot image magic
        MAGIC=$(xxd -l 8 -p "$RECOVERY_IMG" 2>/dev/null || echo "")
        if [[ "$MAGIC" == "414e44524f494421" ]]; then
            echo "âœ… Found Android boot image magic (ANDROID!)"
        else
            echo "âŒ Not detecting Android boot image magic in $RECOVERY_IMG"
            echo "Magic bytes found: $MAGIC (expected: 414e44524f494421)"
            echo "First 32 bytes of file:"
            xxd -l 32 "$RECOVERY_IMG" || true
            exit 1
        fi
        
        # Unpack the recovery image using magiskboot
        echo "ðŸ“¦ Unpacking recovery image..."
        ./magiskboot unpack "$RECOVERY_IMG"
        
        if [ ! -f "ramdisk.cpio" ]; then
            echo "âŒ ramdisk.cpio not found after unpacking"
            exit 1
        fi
        
        echo "âœ… script1.sh completed successfully"
        EOF
        chmod +x script1.sh
        
    - name: Create script2.sh
      run: |
        cat > script2.sh << 'EOF'
        #!/bin/bash
        set -euxo pipefail
        
        echo "ðŸ”§ script2.sh: patching recovery for fastbootd support"
        
        # Extract ramdisk
        echo "ðŸ“¦ Extracting ramdisk..."
        mkdir -p ramdisk
        cd ramdisk
        cpio -idm < ../ramdisk.cpio
        
        # Create system/bin directory for fastbootd
        mkdir -p system/bin
        
        echo "ðŸ”§ Patching init.recovery files for fastbootd support..."
        
        # Patch init.recovery.*.rc files
        for rc_file in init.recovery*.rc; do
            if [ -f "$rc_file" ]; then
                echo "ðŸ”§ Patching $rc_file"
                
                # Add fastbootd service if not already present
                if ! grep -q "service fastbootd" "$rc_file"; then
                    cat >> "$rc_file" << 'RCEOF'
        
        service fastbootd /system/bin/fastbootd
            class core
            user root
            group root system
            disabled
            seclabel u:r:fastbootd:s0
        
        on property:sys.usb.config=fastboot
            start fastbootd
        
        on property:sys.usb.ffs.ready=1 && property:sys.usb.config=fastboot
            write /sys/class/android_usb/android0/enable 0
            write /sys/class/android_usb/android0/idVendor 18d1
            write /sys/class/android_usb/android0/idProduct d00d
            write /sys/class/android_usb/android0/functions fastboot
            write /sys/class/android_usb/android0/enable 1
        
        RCEOF
                    echo "âœ… Added fastbootd service to $rc_file"
                else
                    echo "â„¹ï¸  fastbootd service already exists in $rc_file"
                fi
            fi
        done
        
        # Also check for generic init.rc files
        for rc_file in init.rc; do
            if [ -f "$rc_file" ]; then
                echo "ðŸ”§ Checking $rc_file"
                if ! grep -q "service fastbootd" "$rc_file"; then
                    cat >> "$rc_file" << 'RCEOF'
        
        service fastbootd /system/bin/fastbootd
            class core
            user root
            group root system
            disabled
            seclabel u:r:fastbootd:s0
        
        on property:sys.usb.config=fastboot
            start fastbootd
        
        RCEOF
                    echo "âœ… Added fastbootd service to $rc_file"
                fi
            fi
        done
        
        echo "ðŸ”§ Patching fstab files for dynamic partition support..."
        
        # Patch fstab files for dynamic partitions
        for fstab_file in fstab.*; do
            if [ -f "$fstab_file" ]; then
                echo "ðŸ”§ Patching $fstab_file for dynamic partitions"
                
                # Add logical partition entries if not present
                if ! grep -q "system.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/system /system ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                    echo "âœ… Added system logical partition to $fstab_file"
                fi
                
                if ! grep -q "vendor.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/vendor /vendor ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                    echo "âœ… Added vendor logical partition to $fstab_file"
                fi
                
                if ! grep -q "product.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/product /product ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                    echo "âœ… Added product logical partition to $fstab_file"
                fi
                
                if ! grep -q "odm.*logical" "$fstab_file"; then
                    echo "/dev/block/mapper/odm /odm ext4 ro,barrier=1,discard wait,logical,first_stage_mount" >> "$fstab_file"
                    echo "âœ… Added odm logical partition to $fstab_file"
                fi
            fi
        done
        
        echo "ðŸ”§ Enabling fastboot mode in recovery menu..."
        
        # Patch recovery UI for fastboot mode (if ui.xml exists)
        if [ -f "ui.xml" ]; then
            if ! grep -q "fastboot" "ui.xml"; then
                sed -i 's/<\/recovery>/<item name="fastboot_mode">Enter fastboot mode<\/item><\/recovery>/' ui.xml 2>/dev/null || true
                echo "âœ… Added fastboot mode to recovery menu"
            fi
        fi
        
        echo "ðŸ“¦ Repacking ramdisk..."
        
        # Repack ramdisk
        find . | cpio -o -H newc > ../ramdisk.cpio.new
        cd ..
        mv ramdisk.cpio.new ramdisk.cpio
        
        echo "ðŸ“¦ Repacking recovery image..."
        
        # Repack the recovery image
        ./magiskboot repack recovery.img recovery-patched.img
        
        if [ -f "recovery-patched.img" ]; then
            SIZE=$(stat -c%s "recovery-patched.img")
            echo "âœ… Patched recovery created: $SIZE bytes"
            
            # Verify the patched image has valid magic
            MAGIC_PATCHED=$(xxd -l 8 -p "recovery-patched.img" 2>/dev/null || echo "")
            if [[ "$MAGIC_PATCHED" == "414e44524f494421" ]]; then
                echo "âœ… Patched image has valid Android boot magic"
            else
                echo "âš ï¸  Warning: Patched image may not have valid boot magic"
            fi
        else
            echo "âŒ Failed to create patched recovery"
            exit 1
        fi
        
        echo "ðŸŽ‰ script2.sh completed successfully!"
        EOF
        chmod +x script2.sh
        
    - name: Fetch image from URL
      run: |
        ls
        pwd
        wget "${{github.event.inputs.RECOVERY_URL }}" -O recovery.img
        
    - name: Patch Process-1
      run: |
        chmod a+x script1.sh
        chmod a+x magiskboot
        ./script1.sh || true
        
    - name: Patch Process-2
      run: |
        chmod a+x script2.sh
        ./script2.sh || true
        python3 avbtool extract_public_key --key phh.pem --output phh.pub.bin
        python3 avbtool add_hash_footer --partition_name recovery --partition_size $(wc -c recovery.img |cut -f 1 -d ' ') --image recovery-patched.img --key phh.pem --algorithm SHA256_RSA4096
        mkdir output && cd output
        mv ../recovery-patched.img recovery.img
        tar cvf fastbootd-recovery.tar recovery.img
        md5sum -t fastbootd-recovery.tar >> fastbootd-recovery.tar
        mv fastbootd-recovery.tar fastbootd-recovery.tar.md5
        
    - name: Upload Recovery
      uses: actions/upload-artifact@v4
      with:
        path: output/*.md5
        name: Patched-Recovery
